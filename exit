[1mdiff --git a/AnalysisEngine/AnalysisEngine.cpp b/AnalysisEngine/AnalysisEngine.cpp[m
[1mindex 5238bbd..2d26d49 100644[m
[1m--- a/AnalysisEngine/AnalysisEngine.cpp[m
[1m+++ b/AnalysisEngine/AnalysisEngine.cpp[m
[36m@@ -1,5 +1,7 @@[m
 #include <iostream>[m
 #include <vector>[m
[32m+[m[32m#include <Windows.h>[m
[32m+[m
 #include "XYZPoint.h"[m
 #include "Restraint.h"[m
 #include "Node.h"[m
[36m@@ -10,21 +12,35 @@[m
 #include "Structure.h"[m
 #include "ArmadilloSolver.h"[m
 [m
[32m+[m[32m#pragma comment(lib, "user32")[m
[32m+[m
 int main()[m
 {[m
[31m-	// Define two nodes[m
[31m-	XYZPoint pt1(0.0, 0.0, 0.0);[m
[31m-	XYZPoint pt2(1.0, 0.0, 0.0);[m
[31m-[m
[31m-	Node node1(1, pt1);[m
[31m-	Node node2(2, pt2);[m
[32m+[m	[32m// Full screen[m
[32m+[m	[32m//::SendMessage(::GetConsoleWindow(), WM_SYSKEYDOWN, VK_RETURN, 0x20000000);[m
[32m+[m
[32m+[m	[32m// Create points for nodes[m
[32m+[m	[32mXYZPoint bottomLeft(0.0, 0.0, 0.0);[m
[32m+[m	[32mXYZPoint topLeft(0.0, 0.0, 1.0);[m
[32m+[m	[32mXYZPoint topRight(1.0, 0.0, 1.0);[m
[32m+[m	[32mXYZPoint bottomRight(1.0, 0.0, 0);[m
[32m+[m
[32m+[m	[32m// Define nodes[m
[32m+[m	[32mNode node1(1, bottomLeft);[m
[32m+[m	[32mNode node2(2, topLeft);[m
[32m+[m	[32mNode node3(3, topRight);[m
[32m+[m	[32mNode node4(4, bottomRight);[m
[32m+[m
[32m+[m	[32m// Add nodes to[m[41m [m
 	std::map<unsigned int, Node*> nodes;[m
 	nodes[node1.NodeIndex] = &node1;[m
 	nodes[node2.NodeIndex] = &node2;[m
[32m+[m	[32mnodes[node3.NodeIndex] = &node3;[m
[32m+[m	[32mnodes[node4.NodeIndex] = &node4;[m
 [m
 	// Assign boundary condition to the first node[m
[32m+[m	[32m// and fourth node[m
 	// Fixed for all directions[m
[31m-[m
 	std::vector<bool> fix;[m
 	std::vector<double> fixity;[m
 [m
[36m@@ -34,9 +50,11 @@[m [mint main()[m
 		fixity.push_back(0.0);[m
 	}[m
 [m
[31m-	Restraint res(&node1, fix, fixity);[m
[32m+[m	[32mRestraint leftRestraint(&node1, fix, fixity);[m
[32m+[m	[32mRestraint rightRestraint(&node4, fix, fixity);[m
 	std::map<unsigned int, Restraint*> restraints;[m
[31m-	restraints[1] = &res;[m
[32m+[m	[32mrestraints[1] = &leftRestraint;[m
[32m+[m	[32mrestraints[2] = &rightRestraint;[m
 [m
 	// Create section[m
 	auto area = 1.0;[m
[36m@@ -52,16 +70,21 @@[m [mint main()[m
 	auto rho = 1.0;[m
 	Material mat(e, v, rho);[m
 [m
[31m-	// Create member[m
[31m-	FrameMember member(1, &node1, &node2, &sect, &mat);[m
[32m+[m	[32m// Create members[m
[32m+[m	[32mFrameMember leftColumn(1, &node1, &node2, &sect, &mat);[m
[32m+[m	[32mFrameMember rightColumn(2, &node1, &node2, &sect, &mat);[m
[32m+[m	[32mFrameMember beam(3, &node1, &node2, &sect, &mat);[m
[32m+[m[41m	[m
 	std::map<unsigned int, Element*> members;[m
[31m-	members[member.ElementIndex] = &member;[m
[32m+[m	[32mmembers[leftColumn.ElementIndex] = &leftColumn;[m
[32m+[m	[32mmembers[rightColumn.ElementIndex] = &rightColumn;[m
[32m+[m	[32mmembers[beam.ElementIndex] = &beam;[m
 [m
 	// Add tip load[m
 	double loads[6];[m
[31m-	loads[0] = 0;[m
[32m+[m	[32mloads[0] = 1;[m
 	loads[1] = 0;[m
[31m-	loads[2] = -1;[m
[32m+[m	[32mloads[2] = 0;[m
 	loads[3] = 0;[m
 	loads[4] = 0;[m
 	loads[5] = 0;[m
[36m@@ -72,16 +95,36 @@[m [mint main()[m
 [m
 	std::map<unsigned int, DistributedLoad*> dist;[m
 [m
[31m-	Structure str(&nodes, &members, &restraints, &nload, &dist);[m
[32m+[m	[32m//Structure str(&nodes, &members, &restraints, &nload, &dist);[m
[32m+[m	[32mauto str = new Structure(&nodes, &members, &restraints, &nload, &dist);[m
 [m
 	std::cout << "Model is created successfully" << std::endl;[m
 	std::cout << "Solver starts" << std::endl;[m
 [m
[31m-	auto disps = ArmadilloSolver::GetDisplacementForStaticCase(str);[m
[31m-	ArmadilloSolver::GetMemberEndForcesForLocalCoordinates(member, disps);[m
[31m-	ArmadilloSolver::GetMemberEndForcesForGlobalCoordinates(member, disps);[m
[32m+[m	[32mauto disps = ArmadilloSolver::GetDisplacementForStaticCase(*str);[m
[32m+[m	[32mArmadilloSolver::GetMemberEndForcesForLocalCoordinates(leftColumn, disps);[m
[32m+[m	[32mArmadilloSolver::GetMemberEndForcesForGlobalCoordinates(leftColumn, disps);[m
[32m+[m
[32m+[m	[32m/*for (size_t i = 0; i < str.nDOF; i++)[m
[32m+[m		[32mstd::cout << disps[i] << std::endl;*/[m
[32m+[m
[32m+[m	[32mstd::cout << "Number of DOFS " << str->nDOF << "\n";[m
[32m+[m
[32m+[m	[32mfor (size_t i = 0; i < str->nDOF; i++)[m
[32m+[m	[32m{[m
[32m+[m		[32m//std::cout << "\n";[m
[32m+[m		[32mfor (size_t j = 0; j < str->nDOF; j++)[m
[32m+[m		[32m{[m
[32m+[m			[32mif ((i == j) && (str->StiffnessMatrix[i][j] == 0))[m
[32m+[m				[32mstd::cout << "Zero at diagonal at " << i << " " << j << "\n";[m
[32m+[m
[32m+[m			[32m//std::cout << str->StiffnessMatrix[i][j];[m
[32m+[m		[32m}[m
[32m+[m	[32m}[m
 [m
 	std::cin.get();[m
 [m
[32m+[m	[32mdelete str;[m
[32m+[m
 	return 0;[m
 }[m
\ No newline at end of file[m
[1mdiff --git a/AnalysisEngine/FrameMember.cpp b/AnalysisEngine/FrameMember.cpp[m
[1mindex a04f070..5a89257 100644[m
[1m--- a/AnalysisEngine/FrameMember.cpp[m
[1m+++ b/AnalysisEngine/FrameMember.cpp[m
[36m@@ -6,6 +6,7 @@[m
 [m
 FrameMember::FrameMember(unsigned int ElmIndex, Node* iNode, Node* jNode, Section* section, Material* material)[m
 {[m
[32m+[m	[32mthis->ElementIndex = ElmIndex;[m
 	this->Nodes[0] = iNode;[m
 	this->Nodes[1] = jNode;[m
 	this->FrameSection = section;[m
[1mdiff --git a/AnalysisEngine/Structure.cpp b/AnalysisEngine/Structure.cpp[m
[1mindex 5503912..9e831ff 100644[m
[1m--- a/AnalysisEngine/Structure.cpp[m
[1m+++ b/AnalysisEngine/Structure.cpp[m
[36m@@ -5,6 +5,7 @@[m
 [m
 Structure::Structure(std::map<unsigned int, Node*>* nodeMap, std::map<unsigned int, Element*>* elementMap, std::map<unsigned int, Restraint*>* restraintMap,[m
 	std::map<unsigned int, NodalLoad*>* nodalLoadMap, std::map<unsigned int, DistributedLoad*>* distLoadMap)[m
[32m+[m	[32m: Nodes(nodeMap), Elements(elementMap), Restraints(restraintMap), NodalLoads(nodalLoadMap), DistributedLoads(distLoadMap)[m
 {[m
 	this->Nodes = nodeMap;[m
 	this->Elements = elementMap;[m
